为什么大多数人宁愿吃生活的苦，而不愿意吃学习的苦?因为学习的苦需要自己主动去吃，而生活的苦你躺着它就来了。
X、拼接路径
	 ClassPathResource file = new ClassPathResource("img");
	 String path = file.getFile().getAbsolutePath();
	 cre.setIMG(path + File.separator + cre.getIMG());
X、&&和||的区别
	 a&&b:若a为真（true），b为真（true），结果返回真（true），否则为假（false）
	 a||b:a或b任意一个为真（true） 就返回真（true） ， 否则返回假（false）
X、线程	 
	线程的创建方式：
		1）继承Thread类创建线程，重写run方法
		2）实现Runnable接口创建线程，覆盖run方法
		3）使用Callable接口创建线程，覆盖run方法
		
	X-1、进程和线程的区别
		 进程：是执行中一段程序，一旦程序被载入到内存并准备执行，他就是一个进程，进程时表示资源分配的
			   一个基本概念，又是调度运行的基本单位，是系统中的并发执行的单位！！
		 线程：单个进程中执行中每个任务就是一个线程，线程是进程执行运算的最小单位，一个线程只能属于一个进程
			   但是一个进程可以拥有多个线程，多线程处理就是允许一个进程中在同一时刻执行多个任务。
		 并发：你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发
			   1、两个或者多个事务在同一时间间隔发生
			   2、在同一实体上执行的多个事件	   
		 并行：你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行
			   1、并行是指零个或者多个时间在同一时刻发生
			   2、并行是在不同的实体上的多个事件，
		 解释：在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群
	X-2、什么是进程和线程
			 以谷歌浏览器做例子，进程是大爷进程实际上是不做事的，而是吩咐别人做事，这个“别人”当然只有线程这位苦力了
			 当一个程序（进程）想要做一件事， 比如刷新网页，他就会开启一个线程，让这个线程去做这件事。
			 多线程前面提过，一个进程可以有多个线程。有一点要注意，一个进程至少要有一个线程。这也很好理解，没有线程就没有人“干活”了。
			 还是以浏览器举例，假设我想一边听歌一边写博客，那么我必须打开2个网页，一个用来听歌，一个用来写作。
			 这时候浏览器有2种方案处理，一种是只开一个线程，先执行听歌的任务，等歌播放任务结束后，再让线程执行写作任务。这就是单线程串行执行。
			 不过如果这种方式执行，我估计写博客的想砸电脑。另一种就是多线程方案。
			 浏览器开启2个线程，1个线程负责播放音乐，另1个线程负责打开博客供用户写作。相当于并行处理两个任务，
			 但这里的并行有时候并不是真正的并行，而是将CPU的的时间进行分片，以1秒时间为例，CPU将这1秒时间进行分片，
			 每一片的单位是0.001秒，两个线程轮番占用CPU的时间，最终在2个线程优先级相同的情况下，会各占用CPU 0.5秒的时间。
			 但因为这个切换太快了，用户是根本感觉不到的。但这种机制并不是真正的并行。
	线程的状态：创建(new) -> 就绪 -> 运行 -> 死亡 
									   | 
				堵塞：由于某种原因让某个线程让出CPU并停止自己的执行，即进入阻塞状态	
				正在睡眠：调用sleep()方法让线程进入休眠状态，当指定的时间过去之后该线程重新进入就绪状态继续争夺时间片，线程不会释放对象锁
				正在等待：调用wait()方法。（调用motify()方法回到就绪状态）必须调用notify()唤醒，线程会放弃对象锁
	X-3、线程池
			作用：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。
				  线程池使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务
			好处：利用线程池管理并复用线程、控制最大并发数等。
				  减少线程创建和销毁的次数大大提高性能
		 创建方式： 
			 newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

			 newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。

			 newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。

			 newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
		 线程池的参数
			java.uitl.concurrent.ThreadPoolExecutor类是线程池中最核心的一个类
			ThreadPoolExecutor的七个参数
				corePollSize：核心线程数。在创建了线程池后，线程中没有任何线程，等到有任务到来时才创建线程去执行任务。
							  默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，
							  当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中。
				maximumPoolSize：最大线程数。表明线程中最多能够创建的线程数量
				keepAliveTime：空闲的线程保留的时间。
				TimeUnit：空闲线程的保留时间单位
						  {				
							TimeUnit.DAYS;               //天
							TimeUnit.HOURS;             //小时
							TimeUnit.MINUTES;           //分钟
							TimeUnit.SECONDS;           //秒
							TimeUnit.MILLISECONDS;      //毫秒
							TimeUnit.MICROSECONDS;      //微妙
							TimeUnit.NANOSECONDS;       //纳秒
						  }
				BlockingQueue<Runnable>：阻塞队列，存储等待执行的任务。参数有ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue可选。
				ThreadFactory：线程工厂，用来创建线程
				RejectedExecutionHandler：队列已满，而且任务量大于最大线程的异常处理策略。有以下取值		
X、StringUtils  
     Stirng str="123,456";	 
	 StringUtils.isEmpty(str)//判断字符串是否为空，判断的标准是str==null,str.length()==0	 
	 StringUtils.isNotEmpty(Str)//判断字符串是否非空，相当于！StringUtils.isEmpty(Str);
	 str.startsWith("1")//表示判断参数字符串是否在原字符串的头部。
	 str.endsWith("3")//表示判断参数字符串是否在原字符串的尾部。
	 str.indexOf("1")//表示查找字符串1，第一次出现的位置，没有返回-1
	 str.indexOf("1"，2)//从第2个位置查找字符 1 第一次出现的位置 ，没有返回-1
	 str.contains(",")//如果包含 1 则返回 true 不包含则返回 false
	 str.split(",")//根据，把字符串分开，返回一个字符串数组
	 str.trim()//去除字符串两边多余的空格
	 str.toUpperCase()//转换大小写
X-1、java中的关键字
	 instanceof关键字，它的作用是判断其左边对象是否为其右边类的实例，返回的是boolean类型的数据。用它来判断某个对象是否是某个Class类的实例
X、Springboot
	  1、Springboot如何使用外部tomcat容器？
		 https://www.cnblogs.com/wzk-0000/p/9505265.html
	  2、Springboot使用dbcp连接池
		 https://www.cnblogs.com/yi1036943655/p/9251425.html
X、ArrayList 
     根据源码注释可知，ArrayList是线程不安全的，
	 多线程环境下要通过外部的同步策略后使用，比如List list = Collections.synchronizedList(new ArrayList(…));    
X、JAVA 排序 Collections.sort()方法
	List<Integer> list=new ArrayList<>();
	list.add(1);list.add(5);list.add(3);list.add(2);list.add(10);list.add(7);
	Collections.sort(list);//升序
	System.out.println(list);//升序
	
	Collections.sort(list,Collections.reverseOrder());降序
	System.out.println(list);//降序
	
X、Mybatis框架	
	Mybatis的初始化
		MyBatis的初始化的过程其实就是解析配置文件和初始化Configuration的过程	
	Mybatis的主要成员
		Configuration ： 	Mybatis的所有配置信息都保存在Configuration对象之中，配置文件中的大部分配置都会储存到该类中
		SqlSession ：    	作为Mybatis工作的主要顶层API，表示和数据库交互时的绘画，完成必要数据库增删改查功能
		Executor   ：    	Mybatis执行器，是Mybatis调度的核心，负责sql语句的生成和查询缓存的维护
		StatementHandler ： 封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数等
		ParameterHandler ： 负责对用户传递的参数转换成JDBC Statement 所对应的数据类型
		ResultSetHandler ： 负责将JDBC返回的ResultSet结果集对象转换成List类型的集合
		TypeHandler      ： 负责java数据类型和jdbc数据类型(也可以说是数据表列类型)之间的映射和转换
		MappedStatement  ： MappedStatement维护一条<select|update|delete|insert>节点的封装
		SqlSource        ： 负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回
		BoundSql         ： 表示动态生成的SQL语句以及相应的参数信息
X-1、bean的生命周期
	    1)通过构造方法创建或者工厂创建bean的实例
		2)为bean的属性设置值和对其他bean的引用
		3)调用bean的初始化方法
		4)bean的使用
		5)bean的摧毁
X、 Session介绍
		在WEB开发中，服务器可以为每个用户浏览器创建一个会话对象（session对象），注意：一个浏览器独占一个session对象(默认情况下)。
		因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其它程序时，其它程
		序可以从用户的session中取出该用户的数据，为用户服务
	Session和Cokie的区别
		Cookie是把用户的数据写给用户的浏览器。
		Session技术把用户的数据写到用户独占的session中。
		Session对象由服务器创建，开发人员可以调用request对象的getSession方法得到session对象。	
     HttpServletRequest request; HttpServletResponse response;
		HttpSession session = request.getSession();
		getSession(boolean create)意思是返回当前reqeust中的HttpSession ，
		HttpServletRequest.getSession(ture)等同于 HttpServletRequest.getSession() 
		HttpServletRequest.getSession(false)等同于 如果当前Session没有就为null；
    具体的使用场景
	   当向Session中存取登录信息时，一般建议：HttpSession session =request.getSession();
	   当从Session中获取登录信息时，一般建议：HttpSession session =request.getSession(false);
Y、数据库
	一对一关系举例：
		1、每个中国本土居民和他们唯一的身份证编号
		2、每个班级中唯一的班长，每个班长也只服务于唯一的班级
	一对多关系举例：
		1、一个年级段有多个平行班级，多个平行班都隶属于一个年级段
		2、一个班级有若干个学生，若干个学生隶属于一个班级 
	 多对多关系举例：
		1、一个班级有若干个老师，一个老师也可以带若干个班级
		2、一门课程同时有若干个学生选修，一个学生可以同时选修多门课程
	 多对多关系： 
	    对于多对多关系，需要转换成1对多关系，那么就需要一张中间表来转换，
		这张中间表里面需要存放学生表里面的主键和课程表里面的主键，
	    此时学生与中间表示1对多关系，课程与中间表是1对多关系，学生与课程是多对多关系
Y-1 数据库索引 
	 索引主要分为两大类：聚集索引和非聚集索引
		 在这两大类的索引类型下，还可以降索引分为4个小类型：
			1，普通索引：最基本的索引，没有任何限制，是我们经常使用到的索引。

	        2，唯一索引：与普通索引类似，不同的是，唯一索引的列值必须唯一，但允许为空值。主键索引是特殊的唯一索引，不允许有空值。

	        3，全文索引：全文索引（FULLTEXT）仅可以适用于MyISAM引擎的数据表，作用于CHAR，VARCHAR、TEXT数据类型的列。

	        4、组合索引：将几个列作为一条索引进行检索，使用最左匹配原则。

	 SQL Sever索引类型有：唯一索引，主键索引，聚集索引，非聚集索引，复合索引（组合索引），SQL Sever默认主键为聚集索引，也可以指定为非聚集索引
	 
     MySQL 索引类型有：唯一索引，主键（聚集）索引，非聚集索引，全文索引，复合索引（组合索引）MySQL里主键就是聚集索引
	 
	 其实按照定义，除了聚集索引以外的索引都是非聚集索引
	 
	 MySQL 索引类型normal，unique，full text的区别是什么？
		   normal：表示普通索引
		   unique：表示唯一的，不允许重复的索引，如果该字段信息保证不会重复例如身份证号用作索引时，可设置为unique
		   full textl: 表示 全文搜索的索引。 FULLTEXT 用于搜索很长一篇文章的时候，效果最好。用在比较短的文本，如果就一两行字的，普通的 INDEX 也可以。
		   总结，索引的类别由建立索引的字段内容特性来决定，通常normal最常见
		   
		聚集索引：聚集索引也称聚簇索引，数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。
	              聚集索引能够提高多行检索的速度、非聚簇索引则对单行检索的速度很快。
				  聚集索引和非聚集索引的根本区别是表中记录的物理顺序和索引的排列顺序是否一致。
                  聚集索引的表中记录的物理顺序与索引的排列顺序一致
		建议使用聚集索引的场合为：
				  A.某列包含了小数目的不同值。
				  B.排序和范围查找
y-2	数据库为什么需要锁机制，都有哪些锁机制？ 

     ①为什么要锁？
		数据库是一个多用户使用的共享资源,比如一个用户表t_user,两个浏览器前面的人登录了同个一个账号
		把电话号码改了。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。
		若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性(脏读，不可重复读，幻读等)，
		可能产生死锁。为了解决这个问题，加锁是一个非常重要的技术，对实现数据库并发控制是一个好的方案。
		简单说当一个执行sql语句的事务想要操作表记录之前，先向数据库发出请求，对你访问的记录集加锁，
		在这个事务释放这个锁之前，其他事务不能对这些数据进行更新操作。
		
	 ②有哪些锁？
	    锁包括行级锁、表级锁、悲观锁、乐观锁

X Redis数据库
	优点：
		① 数据库的工作模式按存储方式可分为：硬盘数据库和内存数据库。
		  Redis 将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度极快。
		② Redis采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，
	      官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。这个数据不比采用单进程多线程的同样基于内存的 KV 数据库 Memcached 差
	 redis是单线程
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 